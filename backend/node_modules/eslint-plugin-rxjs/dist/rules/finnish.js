"use strict";
const eslint_etc_1 = require("eslint-etc");
const utils_1 = require("../utils");
const defaultOptions = [];
const rule = utils_1.ruleCreator({
    defaultOptions,
    meta: {
        docs: {
            category: "Stylistic Issues",
            description: "Enforces the use of Finnish notation.",
            recommended: false,
        },
        fixable: undefined,
        messages: {
            forbidden: "Use Finnish notation.",
        },
        schema: [
            {
                properties: {
                    functions: { type: "boolean" },
                    methods: { type: "boolean" },
                    names: { type: "object" },
                    parameters: { type: "boolean" },
                    properties: { type: "boolean" },
                    types: { type: "object" },
                    variables: { type: "boolean" },
                },
                type: "object",
            },
        ],
        type: "problem",
    },
    name: "finnish",
    create: (context, unused) => {
        const { esTreeNodeToTSNodeMap } = eslint_etc_1.getParserServices(context);
        const { couldBeObservable, couldBeType, couldReturnObservable, couldReturnType, } = eslint_etc_1.getTypeServices(context);
        const [config = {}] = context.options;
        const validate = {
            functions: true,
            methods: true,
            parameters: true,
            properties: true,
            variables: true,
            ...config,
        };
        const names = [];
        if (config.names) {
            Object.entries(config.names).forEach(([key, validate]) => {
                names.push({ regExp: new RegExp(key), validate });
            });
        }
        else {
            names.push({
                regExp: /^(canActivate|canActivateChild|canDeactivate|canLoad|intercept|resolve|validate)$/,
                validate: false,
            });
        }
        const types = [];
        if (config.types) {
            Object.entries(config.types).forEach(([key, validate]) => {
                types.push({ regExp: new RegExp(key), validate });
            });
        }
        else {
            types.push({
                regExp: /^EventEmitter$/,
                validate: false,
            });
        }
        function checkNode(nameNode, typeNode) {
            let tsNode = esTreeNodeToTSNodeMap.get(nameNode);
            const text = tsNode.getText();
            if (!/\$$/.test(text) &&
                (couldBeObservable(typeNode || nameNode) ||
                    couldReturnObservable(typeNode || nameNode))) {
                for (const name of names) {
                    const { regExp, validate } = name;
                    if (regExp.test(text) && !validate) {
                        return;
                    }
                }
                for (const type of types) {
                    const { regExp, validate } = type;
                    if ((couldBeType(typeNode || nameNode, regExp) ||
                        couldReturnType(typeNode || nameNode, regExp)) &&
                        !validate) {
                        return;
                    }
                }
                context.report({
                    loc: eslint_etc_1.getLoc(tsNode),
                    messageId: "forbidden",
                });
            }
        }
        return {
            "ArrayPattern > Identifier[name=/[^$]$/]": (node) => {
                const found = eslint_etc_1.findParent(node, "ArrowFunctionExpression", "FunctionDeclaration", "FunctionExpression", "VariableDeclarator");
                if (!found) {
                    return;
                }
                if (!validate.variables && found.type === "VariableDeclarator") {
                    return;
                }
                if (!validate.parameters) {
                    return;
                }
                checkNode(node);
            },
            "ArrowFunctionExpression > Identifier[name=/[^$]$/]": (node) => {
                if (validate.parameters) {
                    const parent = eslint_etc_1.getParent(node);
                    if (node !== parent.body) {
                        checkNode(node);
                    }
                }
            },
            "ClassProperty[key.name=/[^$]$/][computed=false]": (node) => {
                const anyNode = node;
                if (validate.properties) {
                    checkNode(anyNode.key);
                }
            },
            "FunctionDeclaration > Identifier[name=/[^$]$/]": (node) => {
                const parent = eslint_etc_1.getParent(node);
                if (node === parent.id) {
                    if (validate.functions) {
                        checkNode(node, parent);
                    }
                }
                else {
                    if (validate.parameters) {
                        checkNode(node);
                    }
                }
            },
            "FunctionExpression > Identifier[name=/[^$]$/]": (node) => {
                const parent = eslint_etc_1.getParent(node);
                if (node === parent.id) {
                    if (validate.functions) {
                        checkNode(node, parent);
                    }
                }
                else {
                    if (validate.parameters) {
                        checkNode(node);
                    }
                }
            },
            "MethodDefinition[kind='get'][key.name=/[^$]$/][computed=false]": (node) => {
                if (validate.properties) {
                    checkNode(node.key, node);
                }
            },
            "MethodDefinition[kind='method'][key.name=/[^$]$/][computed=false]": (node) => {
                if (validate.methods) {
                    checkNode(node.key, node);
                }
            },
            "MethodDefinition[kind='set'][key.name=/[^$]$/][computed=false]": (node) => {
                if (validate.properties) {
                    checkNode(node.key, node);
                }
            },
            "ObjectExpression > Property[computed=false] > Identifier[name=/[^$]$/]": (node) => {
                if (validate.properties) {
                    const parent = eslint_etc_1.getParent(node);
                    if (node === parent.key) {
                        checkNode(node);
                    }
                }
            },
            "ObjectPattern > Property > Identifier[name=/[^$]$/]": (node) => {
                const found = eslint_etc_1.findParent(node, "ArrowFunctionExpression", "FunctionDeclaration", "FunctionExpression", "VariableDeclarator");
                if (!found) {
                    return;
                }
                if (!validate.variables && found.type === "VariableDeclarator") {
                    return;
                }
                if (!validate.parameters) {
                    return;
                }
                const parent = eslint_etc_1.getParent(node);
                if (node === parent.value) {
                    checkNode(node);
                }
            },
            "TSCallSignatureDeclaration > Identifier[name=/[^$]$/]": (node) => {
                if (validate.parameters) {
                    checkNode(node);
                }
            },
            "TSConstructSignatureDeclaration > Identifier[name=/[^$]$/]": (node) => {
                if (validate.parameters) {
                    checkNode(node);
                }
            },
            "TSMethodSignature[computed=false]": (node) => {
                const anyNode = node;
                if (validate.methods) {
                    checkNode(anyNode.key, node);
                }
                if (validate.parameters) {
                    anyNode.params.forEach((param) => checkNode(param));
                }
            },
            "TSParameterProperty > Identifier[name=/[^$]$/]": (node) => {
                if (validate.parameters || validate.properties) {
                    checkNode(node);
                }
            },
            "TSPropertySignature[key.name=/[^$]$/][computed=false]": (node) => {
                const anyNode = node;
                if (validate.properties) {
                    checkNode(anyNode.key);
                }
            },
            "VariableDeclarator > Identifier[name=/[^$]$/]": (node) => {
                const parent = eslint_etc_1.getParent(node);
                if (validate.variables && node === parent.id) {
                    checkNode(node);
                }
            },
        };
    },
});
module.exports = rule;
