"use strict";
const common_tags_1 = require("common-tags");
const eslint_etc_1 = require("eslint-etc");
const utils_1 = require("../utils");
const defaultOptions = [];
const rule = utils_1.ruleCreator({
    defaultOptions,
    meta: {
        docs: {
            category: "Possible Errors",
            description: "Forbids the application of operators after `takeUntil`.",
            recommended: "error",
        },
        fixable: undefined,
        messages: {
            forbidden: "Applying operators after takeUntil are forbidden.",
        },
        schema: [
            {
                properties: {
                    alias: { type: "array", items: { type: "string" } },
                    allow: { type: "array", items: { type: "string" } },
                },
                type: "object",
                description: common_tags_1.stripIndent `
          An optional object with optional \`alias\` and \`allow\` properties.
          The \`alias\` property is an array containing the names of operators that aliases for \`takeUntil\`.
          The \`allow\` property is an array containing the names of the operators that are allowed to follow \`takeUntil\`.`,
            },
        ],
        type: "problem",
    },
    name: "no-unsafe-takeuntil",
    create: (context, unused) => {
        let checkedOperatorsRegExp = /^takeUntil$/;
        const allowedOperators = [
            "count",
            "defaultIfEmpty",
            "endWith",
            "every",
            "finalize",
            "finally",
            "isEmpty",
            "last",
            "max",
            "min",
            "publish",
            "publishBehavior",
            "publishLast",
            "publishReplay",
            "reduce",
            "share",
            "shareReplay",
            "skipLast",
            "takeLast",
            "throwIfEmpty",
            "toArray",
        ];
        const [config = {}] = context.options;
        const { alias, allow = allowedOperators } = config;
        if (alias) {
            checkedOperatorsRegExp = new RegExp(`^(${alias.concat("takeUntil").join("|")})$`);
        }
        const { couldBeObservable } = eslint_etc_1.getTypeServices(context);
        return {
            [`CallExpression[callee.property.name='pipe'] > CallExpression[callee.name=${checkedOperatorsRegExp}]`]: (node) => {
                const pipeCallExpression = eslint_etc_1.getParent(node);
                if (!pipeCallExpression.arguments ||
                    !couldBeObservable(pipeCallExpression)) {
                    return;
                }
                pipeCallExpression.arguments.reduceRight((isError, arg) => {
                    if (!eslint_etc_1.isCallExpression(arg) || !eslint_etc_1.isIdentifier(arg.callee)) {
                        return true;
                    }
                    if (isError && checkedOperatorsRegExp.test(arg.callee.name)) {
                        context.report({
                            messageId: "forbidden",
                            node: arg.callee,
                        });
                    }
                    return isError || !allow.includes(arg.callee.name);
                }, false);
            },
        };
    },
});
module.exports = rule;
