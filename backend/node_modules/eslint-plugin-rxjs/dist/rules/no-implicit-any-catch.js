"use strict";
const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const eslint_etc_1 = require("eslint-etc");
const utils_1 = require("../utils");
function isProperty(node) {
    return node.type === "Property";
}
const defaultOptions = [];
const rule = utils_1.ruleCreator({
    defaultOptions,
    meta: {
        docs: {
            category: "Possible Errors",
            description: "Forbids implicit `any` error parameters in `catchError` operators.",
            recommended: "error",
            suggestion: true,
        },
        fixable: "code",
        messages: {
            explicitAny: "Explicit `any` in `catchError`.",
            implicitAny: "Implicit `any` in `catchError`.",
            narrowed: "Error type must be `unknown` or `any`.",
            suggestExplicitUnknown: "Use `unknown` instead, this will force you to explicitly and safely assert the type is correct.",
        },
        schema: [
            {
                additionalProperties: false,
                properties: {
                    allowExplicitAny: {
                        type: "boolean",
                    },
                },
                type: "object",
            },
        ],
        type: "suggestion",
    },
    name: "no-implicit-any-catch",
    create: (context, unused) => {
        const [config = {}] = context.options;
        const { allowExplicitAny = false } = config;
        function checkCallback(callback) {
            if (eslint_etc_1.isArrowFunctionExpression(callback) ||
                eslint_etc_1.isFunctionExpression(callback)) {
                const [param] = callback.params;
                if (!param) {
                    return;
                }
                if (eslint_etc_1.hasTypeAnnotation(param)) {
                    const { typeAnnotation } = param;
                    const { typeAnnotation: { type }, } = typeAnnotation;
                    if (type === experimental_utils_1.AST_NODE_TYPES.TSAnyKeyword) {
                        if (allowExplicitAny) {
                            return;
                        }
                        function fix(fixer) {
                            return fixer.replaceText(typeAnnotation, ": unknown");
                        }
                        context.report({
                            fix,
                            messageId: "explicitAny",
                            node: param,
                            suggest: [
                                {
                                    messageId: "suggestExplicitUnknown",
                                    fix,
                                },
                            ],
                        });
                    }
                    else if (type !== experimental_utils_1.AST_NODE_TYPES.TSUnknownKeyword) {
                        function fix(fixer) {
                            return fixer.replaceText(typeAnnotation, ": unknown");
                        }
                        context.report({
                            messageId: "narrowed",
                            node: param,
                            suggest: [
                                {
                                    messageId: "suggestExplicitUnknown",
                                    fix,
                                },
                            ],
                        });
                    }
                }
                else {
                    function fix(fixer) {
                        return fixer.insertTextAfter(param, ": unknown");
                    }
                    context.report({
                        fix,
                        messageId: "implicitAny",
                        node: param,
                        suggest: [
                            {
                                messageId: "suggestExplicitUnknown",
                                fix,
                            },
                        ],
                    });
                }
            }
        }
        return {
            "CallExpression[callee.name='catchError']": (node) => {
                const [callback] = node.arguments;
                if (!callback) {
                    return;
                }
                checkCallback(callback);
            },
            "CallExpression[callee.property.name='subscribe'],CallExpression[callee.name='tap']": (node) => {
                const [observer, callback] = node.arguments;
                if (callback) {
                    checkCallback(callback);
                }
                else if (observer && eslint_etc_1.isObjectExpression(observer)) {
                    const errorProperty = observer.properties.find((property) => isProperty(property) &&
                        eslint_etc_1.isIdentifier(property.key) &&
                        property.key.name === "error");
                    if (errorProperty) {
                        checkCallback(errorProperty.value);
                    }
                }
            },
        };
    },
});
module.exports = rule;
