"use strict";
const tslib_1 = require("tslib");
const common_tags_1 = require("common-tags");
const decamelize_1 = tslib_1.__importDefault(require("decamelize"));
const eslint_etc_1 = require("eslint-etc");
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const defaultOptions = [];
const rule = utils_1.ruleCreator({
    defaultOptions,
    meta: {
        docs: {
            category: "Possible Errors",
            description: "Forbids unsafe `switchMap` usage in effects and epics.",
            recommended: false,
        },
        fixable: undefined,
        messages: {
            forbidden: "Unsafe switchMap usage in effects and epics is forbidden.",
        },
        schema: [
            {
                properties: {
                    allow: {
                        oneOf: [
                            { type: "string" },
                            { type: "array", items: { type: "string" } },
                        ],
                    },
                    disallow: {
                        oneOf: [
                            { type: "string" },
                            { type: "array", items: { type: "string" } },
                        ],
                    },
                    observable: {
                        oneOf: [
                            { type: "string" },
                            { type: "array", items: { type: "string" } },
                        ],
                    },
                },
                type: "object",
                description: common_tags_1.stripIndent `
          An optional object with optional \`allow\`, \`disallow\` and \`observable\` properties.
          The properties can be specified as regular expression strings or as arrays of words.
          The \`allow\` or \`disallow\` properties are mutually exclusive. Whether or not
          \`switchMap\` is allowed will depend upon the matching of action types with \`allow\` or \`disallow\`.
          The \`observable\` property is used to identify the action observables from which effects and epics are composed.
        `,
            },
        ],
        type: "problem",
    },
    name: "no-unsafe-switchmap",
    create: (context, unused) => {
        const defaultDisallow = [
            "add",
            "create",
            "delete",
            "post",
            "put",
            "remove",
            "set",
            "update",
        ];
        let allowRegExp;
        let disallowRegExp;
        let observableRegExp;
        const [config = {}] = context.options;
        if (config.allow || config.disallow) {
            allowRegExp = utils_1.createRegExpForWords(config.allow);
            disallowRegExp = utils_1.createRegExpForWords(config.disallow);
            observableRegExp = new RegExp(config.observable || constants_1.defaultObservable);
        }
        else {
            allowRegExp = null;
            disallowRegExp = utils_1.createRegExpForWords(defaultDisallow);
            observableRegExp = new RegExp(constants_1.defaultObservable);
        }
        const { couldBeObservable } = eslint_etc_1.getTypeServices(context);
        function shouldDisallow(args) {
            const names = args
                .map((arg) => {
                if (eslint_etc_1.isLiteral(arg) && typeof arg.value === "string") {
                    return arg.value;
                }
                if (eslint_etc_1.isIdentifier(arg)) {
                    return arg.name;
                }
                if (eslint_etc_1.isMemberExpression(arg) && eslint_etc_1.isIdentifier(arg.property)) {
                    return arg.property.name;
                }
                return "";
            })
                .map((name) => decamelize_1.default(name));
            if (allowRegExp) {
                return !names.every((name) => allowRegExp.test(name));
            }
            if (disallowRegExp) {
                return names.some((name) => disallowRegExp.test(name));
            }
            return false;
        }
        function checkNode(node) {
            if (!node.arguments || !couldBeObservable(node)) {
                return;
            }
            const hasUnsafeOfType = node.arguments.some((arg) => {
                if (eslint_etc_1.isCallExpression(arg) &&
                    eslint_etc_1.isIdentifier(arg.callee) &&
                    arg.callee.name === "ofType") {
                    return shouldDisallow(arg.arguments);
                }
                return false;
            });
            if (!hasUnsafeOfType) {
                return;
            }
            node.arguments.forEach((arg) => {
                if (eslint_etc_1.isCallExpression(arg) &&
                    eslint_etc_1.isIdentifier(arg.callee) &&
                    arg.callee.name === "switchMap") {
                    context.report({
                        messageId: "forbidden",
                        node: arg.callee,
                    });
                }
            });
        }
        return {
            [`CallExpression[callee.property.name='pipe'][callee.object.name=${observableRegExp}]`]: checkNode,
            [`CallExpression[callee.property.name='pipe'][callee.object.property.name=${observableRegExp}]`]: checkNode,
        };
    },
});
module.exports = rule;
